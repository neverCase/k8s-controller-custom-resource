/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.nevercase.k8s_controller_custom_resource.api.proto;

// Package-wide variables from generator "generated".
option go_package = "proto";

message ConfigMap {
  optional string Name = 1;

  // Data contains the configuration data.
  // Each key must consist of alphanumeric characters, '-', '_' or '.'.
  // Values with non-UTF-8 byte sequences must use the BinaryData field.
  // The keys stored in Data must not overlap with the keys in
  // the BinaryData field, this is enforced during validation process.
  // +optional
  map<string, string> data = 2;
}

message ConfigMapList {
  repeated ConfigMap items = 1;
}

// The shortage ot the harbor projects
message HarborHub {
  optional string name = 1;
}

message HarborHubList {
  repeated HarborHub items = 1;
}

message HarborProject {
  optional int32 projectId = 1;

  optional string name = 2;
}

message HarborProjectList {
  repeated HarborProject items = 1;
}

message HarborRepository {
  optional int32 repositoryId = 1;

  optional string name = 2;

  optional int32 projectId = 3;
}

message HarborRepositoryList {
  repeated HarborRepository items = 1;
}

message HarborRequest {
  optional string harborUrl = 1;

  optional string command = 2;

  optional int32 projectId = 3;

  optional string imageName = 4;
}

message HarborTag {
  optional string digest = 1;

  optional string name = 2;
}

message HarborTagList {
  repeated HarborTag items = 1;
}

message IntOrString {
  optional int32 type = 1;

  optional int32 intVal = 2;

  optional string strVal = 3;
}

message MysqlCrd {
  optional string Name = 1;

  optional NodeSpec master = 2;

  optional NodeSpec slave = 3;
}

message MysqlCrdList {
  repeated MysqlCrd items = 1;
}

message NameSpace {
  optional string Name = 1;
}

message NameSpaceList {
  repeated NameSpace items = 1;
}

message NodeSpec {
  optional string Name = 1;

  optional int32 replicas = 2;

  optional string image = 3;

  optional string imagePullSecrets = 4;

  // The path of the nas disk which was mounted on the machine
  optional string volumePath = 5;

  // PodResource
  optional PodResourceRequirements podResource = 6;
}

message Param {
  optional string service = 1;

  optional string resourceType = 2;

  optional string nameSpace = 3;

  optional string command = 4;
}

// PodResourceRequirements describes the compute resource requirements.
message PodResourceRequirements {
  // Limits describes the maximum amount of compute resources allowed.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, string> limits = 1;

  // Requests describes the minimum amount of compute resources required.
  // If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  // otherwise to an implementation-defined value.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, string> requests = 2;
}

message RedisCrd {
  optional string Name = 1;

  optional NodeSpec master = 2;

  optional NodeSpec slave = 3;
}

message RedisCrdList {
  repeated RedisCrd items = 1;
}

message Request {
  optional Param param = 1;

  optional bytes data = 2;
}

message ResourceList {
  repeated string items = 1;
}

message Response {
  optional int32 code = 1;

  optional Param param = 2;

  optional bytes result = 3;
}

message Secret {
  optional string name = 1;

  optional string nameSpace = 2;
}

message SecretList {
  repeated Secret items = 1;
}

message Service {
  optional string Name = 1;

  // The list of ports that are exposed by this service.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated ServicePort ports = 2;

  // clusterIP is the IP address of the service and is usually assigned
  // randomly by the master. If an address is specified manually and is not in
  // use by others, it will be allocated to the service; otherwise, creation
  // of the service will fail. This field can not be changed through updates.
  // Valid values are "None", empty string (""), or a valid IP address. "None"
  // can be specified for headless services when proxying is not required.
  // Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
  // type is ExternalName.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +optional
  optional string clusterIP = 3;

  // type determines how the Service is exposed. Defaults to ClusterIP. Valid
  // options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  // "ExternalName" maps to the specified externalName.
  // "ClusterIP" allocates a cluster-internal IP address for load-balancing to
  // endpoints. Endpoints are determined by the selector or if that is not
  // specified, by manual construction of an Endpoints object. If clusterIP is
  // "None", no virtual IP is allocated and the endpoints are published as a
  // set of endpoints rather than a stable IP.
  // "NodePort" builds on ClusterIP and allocates a port on every node which
  // routes to the clusterIP.
  // "LoadBalancer" builds on NodePort and creates an
  // external load-balancer (if supported in the current cloud) which routes
  // to the clusterIP.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  // +optional
  optional string type = 4;

  // externalIPs is a list of IP addresses for which nodes in the cluster
  // will also accept traffic for this service.  These IPs are not managed by
  // Kubernetes.  The user is responsible for ensuring that traffic arrives
  // at a node with this IP.  A common example is external load-balancers
  // that are not part of the Kubernetes system.
  // +optional
  repeated string externalIPs = 5;
}

message ServiceList {
  repeated Service items = 1;
}

message ServicePort {
  // The name of this port within the service. This must be a DNS_LABEL.
  // All ports within a ServiceSpec must have unique names. When considering
  // the endpoints for a Service, this must match the 'name' field in the
  // EndpointPort.
  // Optional if only one ServicePort is defined on this service.
  // +optional
  optional string name = 1;

  // The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
  // Default is TCP.
  // +optional
  optional string protocol = 2;

  // The port that will be exposed by this service.
  optional int32 port = 3;

  // Number or name of the port to access on the pods targeted by the service.
  // Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  // If this is a string, it will be looked up as a named port in the
  // target Pod's container ports. If this is not specified, the value
  // of the 'port' field is used (an identity map).
  // This field is ignored for services with clusterIP=None, and should be
  // omitted or set equal to the 'port' field.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  // +optional
  optional IntOrString targetPort = 4;

  // The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
  // Usually assigned by the system. If specified, it will be allocated to the service
  // if unused or else creation of the service will fail.
  // Default is to auto-allocate a port if the ServiceType of this Service requires one.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  // +optional
  optional int32 nodePort = 5;
}

