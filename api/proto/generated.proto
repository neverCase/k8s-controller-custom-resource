/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.nevercase.k8s_controller_custom_resource.api.proto;

// Package-wide variables from generator "generated".
option go_package = "proto";

message ConfigMap {
  optional string Name = 1;

  // An opaque value that represents the internal version of this object that can
  // be used by clients to determine when objects have changed. May be used for optimistic
  // concurrency, change detection, and the watch operation on a resource or set of resources.
  // Clients must treat these values as opaque and passed unmodified back to the server.
  // They may only be valid for a particular resource or set of resources.
  //
  // Populated by the system.
  // Read-only.
  // Value must be treated as opaque by clients and .
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  // +optional
  optional string resourceVersion = 2;

  // Data contains the configuration data.
  // Each key must consist of alphanumeric characters, '-', '_' or '.'.
  // Values with non-UTF-8 byte sequences must use the BinaryData field.
  // The keys stored in Data must not overlap with the keys in
  // the BinaryData field, this is enforced during validation process.
  // +optional
  map<string, string> data = 3;
}

message ConfigMapList {
  repeated ConfigMap items = 1;
}

// Adapts a ConfigMap into a volume.
//
// The contents of the target ConfigMap's Data field will be presented in a
// volume as files using the keys in the Data field as the file names, unless
// the items element is populated with specific mappings of keys to paths.
// ConfigMap volumes support ownership management and SELinux relabeling.
message ConfigMapVolumeSource {
  // LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 1;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;

  // Specify whether the ConfigMap or its keys must be defined
  // +optional
  optional bool optional = 3;
}

// ContainerPort represents a network port in a single container.
message ContainerPort {
  // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  // named port in a pod must have a unique name. Name for the port that can be
  // referred to by services.
  // +optional
  optional string name = 1;

  // Number of port to expose on the host.
  // If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  // Most containers do not need this.
  // +optional
  optional int32 hostPort = 2;

  // Number of port to expose on the pod's IP address.
  // This must be a valid port number, 0 < x < 65536.
  optional int32 containerPort = 3;

  // Protocol for port. Must be UDP, TCP, or SCTP.
  // Defaults to "TCP".
  // +optional
  optional string protocol = 4;

  // What host IP to bind the external port to.
  // +optional
  optional string hostIP = 5;
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  optional string name = 1;

  // Variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  // +optional
  optional string value = 2;
}

// The shortage ot the harbor projects
message HarborHub {
  optional string name = 1;
}

message HarborHubList {
  repeated HarborHub items = 1;
}

message HarborProject {
  optional int32 projectId = 1;

  optional string name = 2;
}

message HarborProjectList {
  repeated HarborProject items = 1;
}

message HarborRepository {
  optional int32 repositoryId = 1;

  optional string name = 2;

  optional int32 projectId = 3;
}

message HarborRepositoryList {
  repeated HarborRepository items = 1;
}

message HarborRequest {
  optional string harborUrl = 1;

  optional string command = 2;

  optional int32 projectId = 3;

  optional string imageName = 4;
}

message HarborTag {
  optional string digest = 1;

  optional string name = 2;
}

message HarborTagList {
  repeated HarborTag items = 1;
}

message HelixSagaApp {
  optional NodeSpec spec = 1;

  // Entrypoint array. Not executed within a shell.
  // The docker image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string command = 2;

  // Arguments to the entrypoint.
  // The docker image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string args = 3;
}

message HelixSagaConfigMapVolume {
  optional Volume volume = 1;

  optional VolumeMount volumeMount = 2;
}

// HelixSaga Operator
message HelixSagaCrd {
  optional string name = 1;

  // An opaque value that represents the internal version of this object that can
  // be used by clients to determine when objects have changed. May be used for optimistic
  // concurrency, change detection, and the watch operation on a resource or set of resources.
  // Clients must treat these values as opaque and passed unmodified back to the server.
  // They may only be valid for a particular resource or set of resources.
  //
  // Populated by the system.
  // Read-only.
  // Value must be treated as opaque by clients and .
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  // +optional
  optional string resourceVersion = 2;

  optional HelixSagaConfigMapVolume configMap = 3;

  repeated HelixSagaApp applications = 4;
}

message HelixSagaCrdList {
  repeated HelixSagaCrd items = 1;
}

message IntOrString {
  optional int32 type = 1;

  optional int32 intVal = 2;

  optional string strVal = 3;
}

// Maps a string key to a path within a volume.
message KeyToPath {
  // The key to project.
  optional string key = 1;

  // The relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  optional string path = 2;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 3;
}

message MysqlCrd {
  optional string name = 1;

  // An opaque value that represents the internal version of this object that can
  // be used by clients to determine when objects have changed. May be used for optimistic
  // concurrency, change detection, and the watch operation on a resource or set of resources.
  // Clients must treat these values as opaque and passed unmodified back to the server.
  // They may only be valid for a particular resource or set of resources.
  //
  // Populated by the system.
  // Read-only.
  // Value must be treated as opaque by clients and .
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  // +optional
  optional string resourceVersion = 2;

  optional NodeSpec master = 3;

  optional NodeSpec slave = 4;
}

message MysqlCrdList {
  repeated MysqlCrd items = 1;
}

message NameSpace {
  optional string Name = 1;
}

message NameSpaceList {
  repeated NameSpace items = 1;
}

message NodeSpec {
  optional string name = 1;

  optional int32 replicas = 2;

  optional string image = 3;

  optional string imagePullSecrets = 4;

  // The path of the nas disk which was mounted on the machine
  optional string volumePath = 5;

  // PodResource
  optional PodResourceRequirements podResource = 6;

  // List of ports to expose from the container. Exposing a port here gives
  // the system additional information about the network connections a
  // container uses, but is primarily informational. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated ContainerPort containerPorts = 7;

  // The list of ports that are exposed by this service.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated ServicePort servicePorts = 8;

  // List of environment variables to set in the container.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated EnvVar env = 9;

  // The status of the specific StatefulSet which was owned by the crd
  // +optional
  optional Status status = 10;
}

message Param {
  optional string service = 1;

  optional string resourceType = 2;

  optional string nameSpace = 3;

  optional string watchEventType = 4;

  // The request parameters of the HarborApi
  // only used for HarborApi
  optional HarborRequest harborRequest = 5;
}

// PodResourceRequirements describes the compute resource requirements.
message PodResourceRequirements {
  // Limits describes the maximum amount of compute resources allowed.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, string> limits = 1;

  // Requests describes the minimum amount of compute resources required.
  // If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  // otherwise to an implementation-defined value.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, string> requests = 2;
}

message RedisCrd {
  optional string name = 1;

  // An opaque value that represents the internal version of this object that can
  // be used by clients to determine when objects have changed. May be used for optimistic
  // concurrency, change detection, and the watch operation on a resource or set of resources.
  // Clients must treat these values as opaque and passed unmodified back to the server.
  // They may only be valid for a particular resource or set of resources.
  //
  // Populated by the system.
  // Read-only.
  // Value must be treated as opaque by clients and .
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  // +optional
  optional string resourceVersion = 2;

  optional NodeSpec master = 3;

  optional NodeSpec slave = 4;
}

message RedisCrdList {
  repeated RedisCrd items = 1;
}

message Request {
  optional Param param = 1;

  optional bytes data = 2;
}

message ResourceList {
  repeated string items = 1;
}

message Response {
  optional int32 code = 1;

  optional Param param = 2;

  optional bytes result = 3;
}

message Secret {
  optional string name = 1;

  optional string nameSpace = 2;
}

message SecretList {
  repeated Secret items = 1;
}

message Service {
  optional string Name = 1;

  // The list of ports that are exposed by this service.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated ServicePort ports = 2;

  // clusterIP is the IP address of the service and is usually assigned
  // randomly by the master. If an address is specified manually and is not in
  // use by others, it will be allocated to the service; otherwise, creation
  // of the service will fail. This field can not be changed through updates.
  // Valid values are "None", empty string (""), or a valid IP address. "None"
  // can be specified for headless services when proxying is not required.
  // Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
  // type is ExternalName.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +optional
  optional string clusterIP = 3;

  // type determines how the Service is exposed. Defaults to ClusterIP. Valid
  // options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  // "ExternalName" maps to the specified externalName.
  // "ClusterIP" allocates a cluster-internal IP address for load-balancing to
  // endpoints. Endpoints are determined by the selector or if that is not
  // specified, by manual construction of an Endpoints object. If clusterIP is
  // "None", no virtual IP is allocated and the endpoints are published as a
  // set of endpoints rather than a stable IP.
  // "NodePort" builds on ClusterIP and allocates a port on every node which
  // routes to the clusterIP.
  // "LoadBalancer" builds on NodePort and creates an
  // external load-balancer (if supported in the current cloud) which routes
  // to the clusterIP.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  // +optional
  optional string type = 4;

  // externalIPs is a list of IP addresses for which nodes in the cluster
  // will also accept traffic for this service.  These IPs are not managed by
  // Kubernetes.  The user is responsible for ensuring that traffic arrives
  // at a node with this IP.  A common example is external load-balancers
  // that are not part of the Kubernetes system.
  // +optional
  repeated string externalIPs = 5;
}

message ServiceList {
  repeated Service items = 1;
}

message ServicePort {
  // The name of this port within the service. This must be a DNS_LABEL.
  // All ports within a ServiceSpec must have unique names. When considering
  // the endpoints for a Service, this must match the 'name' field in the
  // EndpointPort.
  // Optional if only one ServicePort is defined on this service.
  // +optional
  optional string name = 1;

  // The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
  // Default is TCP.
  // +optional
  optional string protocol = 2;

  // The port that will be exposed by this service.
  optional int32 port = 3;

  // Number or name of the port to access on the pods targeted by the service.
  // Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  // If this is a string, it will be looked up as a named port in the
  // target Pod's container ports. If this is not specified, the value
  // of the 'port' field is used (an identity map).
  // This field is ignored for services with clusterIP=None, and should be
  // omitted or set equal to the 'port' field.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  // +optional
  optional IntOrString targetPort = 4;

  // The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
  // Usually assigned by the system. If specified, it will be allocated to the service
  // if unused or else creation of the service will fail.
  // Default is to auto-allocate a port if the ServiceType of this Service requires one.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  // +optional
  optional int32 nodePort = 5;

  // type determines how the Service is exposed. Defaults to ClusterIP. Valid
  // options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  // "ExternalName" maps to the specified externalName.
  // "ClusterIP" allocates a cluster-internal IP address for load-balancing to
  // endpoints. Endpoints are determined by the selector or if that is not
  // specified, by manual construction of an Endpoints object. If clusterIP is
  // "None", no virtual IP is allocated and the endpoints are published as a
  // set of endpoints rather than a stable IP.
  // "NodePort" builds on ClusterIP and allocates a port on every node which
  // routes to the clusterIP.
  // "LoadBalancer" builds on NodePort and creates an
  // external load-balancer (if supported in the current cloud) which routes
  // to the clusterIP.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  // +optional
  optional string serviceType = 6;
}

// Status
message Status {
  // observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
  // StatefulSet's generation, which is updated on mutation by the API Server.
  // +optional
  optional int64 observedGeneration = 1;

  // replicas is the number of Pods created by the StatefulSet controller.
  optional int32 replicas = 2;

  // readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.
  optional int32 readyReplicas = 3;

  // currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  // indicated by currentRevision.
  optional int32 currentReplicas = 4;

  // updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  // indicated by updateRevision.
  optional int32 updatedReplicas = 5;

  // currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
  // sequence [0,currentReplicas).
  optional string currentRevision = 6;

  // updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
  // [replicas-updatedReplicas,replicas)
  optional string updateRevision = 7;

  // collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
  // uses this field as a collision avoidance mechanism when it needs to create the name for the
  // newest ControllerRevision.
  // +optional
  optional int32 collisionCount = 9;
}

// Volume represents a named volume in a pod that may be accessed by any container in the pod.
message Volume {
  // Volume's name.
  // Must be a DNS_LABEL and unique within the pod.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 1;

  // VolumeSource represents the location and type of the mounted volume.
  // If not specified, the Volume is implied to be an EmptyDir.
  // This implied behavior is deprecated and will be removed in a future version.
  optional VolumeSource volumeSource = 2;
}

// VolumeMount describes a mounting of a Volume within a container.
message VolumeMount {
  // This must match the Name of a Volume.
  optional string name = 1;

  // Mounted read-only if true, read-write otherwise (false or unspecified).
  // Defaults to false.
  // +optional
  optional bool readOnly = 2;

  // Path within the container at which the volume should be mounted.  Must
  // not contain ':'.
  optional string mountPath = 3;

  // Path within the volume from which the container's volume should be mounted.
  // Defaults to "" (volume's root).
  // +optional
  optional string subPath = 4;

  // mountPropagation determines how mounts are propagated from the host
  // to container and the other way around.
  // When not set, MountPropagationNone is used.
  // This field is beta in 1.10.
  // +optional
  // MountPropagation *MountPropagationMode `json:"mountPropagation,omitempty" protobuf:"bytes,5,opt,name=mountPropagation,casttype=MountPropagationMode"`
  // Expanded path within the volume from which the container's volume should be mounted.
  // Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
  // Defaults to "" (volume's root).
  // SubPathExpr and SubPath are mutually exclusive.
  // +optional
  optional string subPathExpr = 6;
}

// Represents the source of a volume to mount.
// Only one of its members may be specified.
message VolumeSource {
  // ConfigMap's name.
  // Must be a DNS_LABEL and unique within the pod.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 1;

  // ConfigMap represents a configMap that should populate this volume
  // +optional
  optional ConfigMapVolumeSource configMap = 2;
}

